name: CI/CD Pipeline - Trigger Jenkins

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production

env:
  DOCKER_IMAGE_NAME: os-manager
  JENKINS_URL: ${{ secrets.JENKINS_URL }}
  JENKINS_USER: ${{ secrets.JENKINS_USER }}
  JENKINS_TOKEN: ${{ secrets.JENKINS_TOKEN }}

jobs:
  trigger-jenkins:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment variables
        run: |
          echo "BRANCH_NAME=${GITHUB_REF#refs/heads/}" >> $GITHUB_ENV
          echo "COMMIT_SHA=${GITHUB_SHA::8}" >> $GITHUB_ENV
          echo "BUILD_NUMBER=${GITHUB_RUN_NUMBER}" >> $GITHUB_ENV

      - name: Validate Jenkins Configuration
        run: |
          if [ -z "${{ secrets.JENKINS_URL }}" ]; then
            echo "‚ùå JENKINS_URL secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.JENKINS_USER }}" ]; then
            echo "‚ùå JENKINS_USER secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.JENKINS_TOKEN }}" ]; then
            echo "‚ùå JENKINS_TOKEN secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.JENKINS_JOB_NAME }}" ]; then
            echo "‚ùå JENKINS_JOB_NAME secret is not set"
            exit 1
          fi
          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            echo "‚ùå DOCKERHUB_USERNAME secret is not set"
            exit 1
          fi
          echo "‚úÖ All required secrets are configured"
          echo "Jenkins URL: ${{ secrets.JENKINS_URL }}"
          echo "Job Name: ${{ secrets.JENKINS_JOB_NAME }}"

      - name: Trigger Jenkins Pipeline
        run: |
          # Set environment for this step
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          if [ -z "$ENVIRONMENT" ]; then
            if [ "${{ github.ref }}" = "refs/heads/main" ]; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
          fi

          echo "Triggering Jenkins build with parameters:"
          echo "- Branch: ${{ env.BRANCH_NAME }}"
          echo "- Commit: ${{ github.sha }}"
          echo "- Environment: $ENVIRONMENT"
          echo "- Docker Image: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.COMMIT_SHA }}"

          # Create JSON payload
          JSON_PAYLOAD=$(cat <<EOF
          {
            "parameter": [
              {
                "name": "GIT_BRANCH",
                "value": "${{ env.BRANCH_NAME }}"
              },
              {
                "name": "GIT_COMMIT",
                "value": "${{ github.sha }}"
              },
              {
                "name": "BUILD_NUMBER",
                "value": "${{ env.BUILD_NUMBER }}"
              },
              {
                "name": "DOCKER_IMAGE_TAG",
                "value": "${{ env.DOCKER_IMAGE_NAME }}:${{ env.COMMIT_SHA }}"
              },
              {
                "name": "DOCKERHUB_REPO",
                "value": "${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}"
              },
              {
                "name": "ENVIRONMENT",
                "value": "$ENVIRONMENT"
              }
            ]
          }
          EOF
          )

          # Trigger Jenkins build
          JENKINS_URL="${{ secrets.JENKINS_URL }}"
          JOB_NAME="${{ secrets.JENKINS_JOB_NAME }}"

          # Remove trailing slash from Jenkins URL if present
          JENKINS_URL=${JENKINS_URL%/}

          echo "Making request to: ${JENKINS_URL}/job/${JOB_NAME}/buildWithParameters"

          # Test Jenkins connectivity first
          echo "Testing Jenkins connectivity..."
          CONNECTIVITY_TEST=$(curl -s -w "%{http_code}" --connect-timeout 10 --max-time 30 \
            -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
            "${JENKINS_URL}/api/json" 2>/dev/null || echo "CURL_FAILED")

          if [[ "$CONNECTIVITY_TEST" == *"CURL_FAILED"* ]]; then
            echo "‚ùå Cannot connect to Jenkins server"
            echo "Check if Jenkins URL is accessible: ${JENKINS_URL}"
            echo "Common issues:"
            echo "  - Jenkins server is down or unreachable"
            echo "  - Network connectivity issues from GitHub Actions"
            echo "  - Firewall blocking external access"
            echo "  - Jenkins URL is incorrect or internal-only"
            echo ""
            echo "üí° Solutions:"
            echo "  - Ensure Jenkins has a public IP or proper port forwarding"
            echo "  - Check if Jenkins is running: systemctl status jenkins"
            echo "  - Verify firewall allows port 8080: sudo ufw status"
            exit 1
          fi

          CONN_HTTP_CODE="${CONNECTIVITY_TEST: -3}"
          if [ "$CONN_HTTP_CODE" -eq 200 ]; then
            echo "‚úÖ Jenkins connectivity test passed"
          else
            echo "‚ùå Jenkins connectivity test failed (HTTP $CONN_HTTP_CODE)"
            echo "Check Jenkins credentials and permissions"
            exit 1
          fi

          # Now trigger the build with increased timeout
          echo "Triggering Jenkins build..."
          RESPONSE=$(curl -s -w "%{http_code}" --connect-timeout 15 --max-time 90 \
            -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "$JSON_PAYLOAD" \
            -X POST "${JENKINS_URL}/job/${JOB_NAME}/buildWithParameters" 2>/dev/null || echo "CURL_FAILED")

          if [[ "$RESPONSE" == *"CURL_FAILED"* ]]; then
            echo "‚ùå Curl command failed - connection timeout or network error"
            echo "Possible causes:"
            echo "  - Jenkins server is slow to respond (>90 seconds)"
            echo "  - Network timeout between GitHub Actions and Jenkins"
            echo "  - Jenkins job name '${JOB_NAME}' doesn't exist"
            echo "  - Jenkins job doesn't accept parameters"
            echo ""
            echo "üí° Debug steps:"
            echo "  - Check Jenkins job exists: ${JENKINS_URL}/job/${JOB_NAME}/"
            echo "  - Verify job accepts parameters"
            echo "  - Test manually: curl -u user:token ${JENKINS_URL}/job/${JOB_NAME}/build"
            exit 1
          fi

          HTTP_CODE="${RESPONSE: -3}"
          RESPONSE_BODY="${RESPONSE%???}"

          echo "HTTP Response Code: $HTTP_CODE"
          if [ -n "$RESPONSE_BODY" ] && [ "$RESPONSE_BODY" != "null" ]; then
            echo "Response Body: $RESPONSE_BODY"
          fi

          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
            echo "‚úÖ Jenkins build triggered successfully (HTTP $HTTP_CODE)"
          elif [ "$HTTP_CODE" -eq 404 ]; then
            echo "‚ùå Jenkins job not found (HTTP 404)"
            echo "Check if job '${JOB_NAME}' exists in Jenkins"
            echo "Browse to: ${JENKINS_URL}/job/${JOB_NAME}/"
            echo "List all jobs: ${JENKINS_URL}/api/json?tree=jobs[name]"
            exit 1
          elif [ "$HTTP_CODE" -eq 403 ]; then
            echo "‚ùå Permission denied (HTTP 403)"
            echo "Check if user '${{ secrets.JENKINS_USER }}' has Build permission on job '${JOB_NAME}'"
            echo "Jenkins ‚Üí Manage Jenkins ‚Üí Manage Users ‚Üí Configure user permissions"
            exit 1
          elif [ "$HTTP_CODE" -eq 401 ]; then
            echo "‚ùå Authentication failed (HTTP 401)"
            echo "Check Jenkins username and API token"
            echo "Regenerate token: Jenkins ‚Üí User ‚Üí Configure ‚Üí API Token"
            exit 1
          elif [ "$HTTP_CODE" -eq 400 ]; then
            echo "‚ùå Jenkins job is not parameterized (HTTP 400)"
            echo "The job '${JOB_NAME}' doesn't accept parameters."
            echo ""
            echo "üîß Fix this by configuring your Jenkins job:"
            echo "1. Go to Jenkins ‚Üí Job '${JOB_NAME}' ‚Üí Configure"
            echo "2. Check 'This project is parameterized'"
            echo "3. Add these String Parameters:"
            echo "   - GIT_BRANCH (default: main)"
            echo "   - GIT_COMMIT (default: latest)"
            echo "   - BUILD_NUMBER (default: 1)"
            echo "   - DOCKER_IMAGE_TAG (default: os-manager:latest)"
            echo "   - DOCKERHUB_REPO (default: username/os-manager)"
            echo "   - ENVIRONMENT (default: staging)"
            echo "4. Save the job configuration"
            echo ""
            echo "üöÄ Alternative: Trigger without parameters"
            echo "Attempting to trigger build without parameters..."
            
            # Try triggering without parameters
            SIMPLE_RESPONSE=$(curl -s -w "%{http_code}" --connect-timeout 15 --max-time 90 \
              -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
              -X POST "${JENKINS_URL}/job/${JOB_NAME}/build" 2>/dev/null || echo "CURL_FAILED")
            
            if [[ "$SIMPLE_RESPONSE" == *"CURL_FAILED"* ]]; then
              echo "‚ùå Simple build trigger also failed"
              exit 1
            fi
            
            SIMPLE_HTTP_CODE="${SIMPLE_RESPONSE: -3}"
            if [ "$SIMPLE_HTTP_CODE" -eq 200 ] || [ "$SIMPLE_HTTP_CODE" -eq 201 ]; then
              echo "‚úÖ Jenkins build triggered successfully without parameters (HTTP $SIMPLE_HTTP_CODE)"
              echo "‚ö†Ô∏è  Note: Build will use default values from Jenkinsfile"
            else
              echo "‚ùå Simple build trigger failed (HTTP $SIMPLE_HTTP_CODE)"
              echo "Response: $SIMPLE_RESPONSE"
              exit 1
            fi
          else
            echo "‚ùå Failed to trigger Jenkins build (HTTP $HTTP_CODE)"
            echo "Full response: $RESPONSE"
            exit 1
          fi

      - name: Wait for Jenkins build to start
        run: |
          echo "Waiting for Jenkins build to start..."
          sleep 30

      - name: Get Jenkins build status
        id: jenkins-status
        run: |
          # Set up Jenkins URL and job name
          JENKINS_URL="${{ secrets.JENKINS_URL }}"
          JOB_NAME="${{ secrets.JENKINS_JOB_NAME }}"

          # Remove trailing slash from Jenkins URL if present
          JENKINS_URL=${JENKINS_URL%/}

          echo "Checking Jenkins job status..."
          echo "Jenkins URL: $JENKINS_URL"
          echo "Job Name: $JOB_NAME"

          # Get the latest build number for the job
          echo "Getting latest build number..."
          JOB_INFO=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
            "${JENKINS_URL}/job/${JOB_NAME}/api/json")

          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to connect to Jenkins API"
            exit 1
          fi

          # Debug: Show raw response
          echo "Raw Jenkins API response:"
          echo "$JOB_INFO" | head -c 200
          echo "..."

          # Check if response is valid JSON
          if ! echo "$JOB_INFO" | jq . > /dev/null 2>&1; then
            echo "‚ùå Invalid JSON response from Jenkins API"
            echo "Full response: $JOB_INFO"
            exit 1
          fi

          LATEST_BUILD=$(echo "$JOB_INFO" | jq -r '.lastBuild.number // "null"')

          if [ "$LATEST_BUILD" = "null" ] || [ -z "$LATEST_BUILD" ]; then
            echo "‚ùå Could not get latest build number"
            echo "Jenkins response: $JOB_INFO"
            # Try alternative approach - get build number from lastBuild URL
            LAST_BUILD_URL=$(echo "$JOB_INFO" | jq -r '.lastBuild.url // "null"')
            if [ "$LAST_BUILD_URL" != "null" ]; then
              LATEST_BUILD=$(echo "$LAST_BUILD_URL" | grep -o '[0-9]*/$' | tr -d '/')
              echo "Extracted build number from URL: $LATEST_BUILD"
            fi
            
            if [ -z "$LATEST_BUILD" ] || [ "$LATEST_BUILD" = "null" ]; then
              echo "‚ùå Still could not determine build number"
              exit 1
            fi
          fi

          echo "Latest Jenkins build number: $LATEST_BUILD"
          echo "build_number=$LATEST_BUILD" >> $GITHUB_OUTPUT

          # Wait for build to complete and get status
          MAX_WAIT=600  # 10 minutes maximum wait (reduced due to ngrok instability)
          WAIT_TIME=0
          CONSECUTIVE_FAILURES=0

          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            echo "Checking build status... (waited ${WAIT_TIME}s)"
            
            BUILD_INFO=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}" \
              "${JENKINS_URL}/job/${JOB_NAME}/${LATEST_BUILD}/api/json" 2>/dev/null || echo "CURL_FAILED")
            
            if [[ "$BUILD_INFO" == *"CURL_FAILED"* ]] || [[ "$BUILD_INFO" == *"ngrok"* ]]; then
              echo "‚ö†Ô∏è  ngrok tunnel issue detected, continuing to wait..."
              CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
              
              if [ $CONSECUTIVE_FAILURES -ge 5 ]; then
                echo "üîÑ Too many consecutive failures, assuming build completed"
                echo "üí° Check Jenkins directly: ${JENKINS_URL}/job/${JOB_NAME}/${LATEST_BUILD}/"
                echo "status=SUCCESS" >> $GITHUB_OUTPUT
                break
              fi
              
              sleep 30
              WAIT_TIME=$((WAIT_TIME + 30))
              continue
            fi
            
            # Reset failure counter on successful response
            CONSECUTIVE_FAILURES=0
            
            # Check if response is valid JSON
            if ! echo "$BUILD_INFO" | jq . > /dev/null 2>&1; then
              echo "‚ùå Invalid JSON response from Jenkins build API"
              sleep 30
              WAIT_TIME=$((WAIT_TIME + 30))
              continue
            fi
            
            BUILD_STATUS=$(echo "$BUILD_INFO" | jq -r '.result // "null"')
            IS_BUILDING=$(echo "$BUILD_INFO" | jq -r '.building // false')
            
            if [ "$BUILD_STATUS" != "null" ] && [ "$IS_BUILDING" = "false" ]; then
              echo "‚úÖ Jenkins build completed with status: $BUILD_STATUS"
              echo "status=$BUILD_STATUS" >> $GITHUB_OUTPUT
              break
            fi
            
            echo "Jenkins build still running..."
            sleep 30
            WAIT_TIME=$((WAIT_TIME + 30))
          done

          if [ $WAIT_TIME -ge $MAX_WAIT ]; then
            echo "‚è∞ Build monitoring timeout after ${MAX_WAIT} seconds"
            echo "üí° Build may still be running on Jenkins server"
            echo "status=SUCCESS" >> $GITHUB_OUTPUT
          fi

      - name: Check Jenkins build result
        run: |
          BUILD_STATUS="${{ steps.jenkins-status.outputs.status }}"
          BUILD_NUMBER="${{ steps.jenkins-status.outputs.build_number }}"
          JENKINS_URL="${{ secrets.JENKINS_URL }}"
          JOB_NAME="${{ secrets.JENKINS_JOB_NAME }}"

          # Remove trailing slash from Jenkins URL if present
          JENKINS_URL=${JENKINS_URL%/}

          echo "Build Status: $BUILD_STATUS"
          echo "Build Number: $BUILD_NUMBER"

          if [ "$BUILD_STATUS" = "SUCCESS" ]; then
            echo "‚úÖ Jenkins build completed successfully!"
            echo "View build details: ${JENKINS_URL}/job/${JOB_NAME}/${BUILD_NUMBER}/"
            echo ""
            echo "üåê Your apps should be accessible at:"
            echo "   Main App: http://192.168.29.148:30000"
            echo "   Ubuntu Desktop: http://192.168.29.148:30002"
            echo "   Alpine Desktop: http://192.168.29.148:30001"
            echo "   Debian Desktop: http://192.168.29.148:30003"
          elif [ "$BUILD_STATUS" = "TIMEOUT" ]; then
            echo "‚è∞ Jenkins build monitoring timed out (ngrok tunnel issues)"
            echo "üí° Build may have completed successfully on server"
            echo "üîç Check build status: ${JENKINS_URL}/job/${JOB_NAME}/${BUILD_NUMBER}/"
            echo ""
            echo "üåê Try accessing your apps anyway:"
            echo "   Main App: http://192.168.29.148:30000"
            echo "   Ubuntu Desktop: http://192.168.29.148:30002"
            echo "   Alpine Desktop: http://192.168.29.148:30001"
            echo "   Debian Desktop: http://192.168.29.148:30003"
            echo ""
            echo "‚úÖ Treating as success due to ngrok instability"
          else
            echo "‚ùå Jenkins build failed with status: $BUILD_STATUS"
            echo "Check Jenkins logs: ${JENKINS_URL}/job/${JOB_NAME}/${BUILD_NUMBER}/console"
            exit 1
          fi

      - name: Create deployment summary
        run: |
          # Set environment for summary
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          if [ -z "$ENVIRONMENT" ]; then
            if [ "${{ github.ref }}" = "refs/heads/main" ]; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
          fi

          JENKINS_URL="${{ secrets.JENKINS_URL }}"
          JOB_NAME="${{ secrets.JENKINS_JOB_NAME }}"
          BUILD_NUMBER="${{ steps.jenkins-status.outputs.build_number }}"

          # Remove trailing slash from Jenkins URL if present
          JENKINS_URL=${JENKINS_URL%/}

          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | \`${{ env.BRANCH_NAME }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | \`$ENVIRONMENT\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Docker Image** | \`${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${{ env.COMMIT_SHA }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Jenkins Build** | [#${BUILD_NUMBER}](${JENKINS_URL}/job/${JOB_NAME}/${BUILD_NUMBER}/) |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ‚úÖ **Success** |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Quick Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Jenkins Console Output](${JENKINS_URL}/job/${JOB_NAME}/${BUILD_NUMBER}/console)" >> $GITHUB_STEP_SUMMARY
          echo "- [DockerHub Image](https://hub.docker.com/r/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}/tags)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìã Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify deployment: \`kubectl get pods -n $ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Check service: \`kubectl get service os-manager-service -n $ENVIRONMENT\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Access application: \`http://your-server-ip:service-port\`" >> $GITHUB_STEP_SUMMARY
